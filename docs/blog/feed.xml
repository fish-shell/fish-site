<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://fishshell.com/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://fishshell.com/" rel="alternate" type="text/html" /><updated>2025-09-27T22:25:46+02:00</updated><id>https://fishshell.com/blog/feed.xml</id><title type="html">Fish-shell Blog</title><entry><title type="html">What’s new in fish 4.0</title><link href="https://fishshell.com/blog/new-in-40/" rel="alternate" type="text/html" title="What’s new in fish 4.0" /><published>2025-02-27T00:00:00+01:00</published><updated>2025-02-27T00:00:00+01:00</updated><id>https://fishshell.com/blog/new-in-40</id><content type="html" xml:base="https://fishshell.com/blog/new-in-40/"><![CDATA[<p>We’re proud to announce the release of <a href="https://github.com/fish-shell/fish-shell/releases/tag/4.0.0">fish 4.0</a>.</p>

<p>This release represents 2731 commits by over 200 people.
It has 1185 files changed, 111221 insertions(+), 89168 deletions(-)<sup id="fnref:linecount"><a href="#fn:linecount" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>.</p>

<p>As you might know, fish was entirely rewritten in rust. But, while that’s a lot of work, it should also be invisible to you, the user - if we’ve done our job right.</p>

<p>Thankfully, this release is also full of cool new features and other improvements.</p>

<p>We’ve written about <a href="../rustport/index.html">the port before</a>, the rest of this post will tell you what awaits you if you’re interested in using fish 4.</p>

<p>For the full list of changes you can see <a href="https://fishshell.com/docs/4.0/relnotes.html">the Release Notes</a>, this is the highlights, curated and explained.</p>

<h2 id="so-what-was-changed-for-me-then">So, what was changed for me, then?</h2>

<h3 id="bind-notation-and-improved-key-chord-support">Bind Notation and Improved Key Chord Support</h3>

<p>Fish’s <code class="language-plaintext highlighter-rouge">bind</code> now has a key notation. That means you no longer have to write <code class="language-plaintext highlighter-rouge">bind \e\[1\;5C</code> or <code class="language-plaintext highlighter-rouge">bind \e\x7F</code>, which directly reflects the escape sequences the terminal sends, you can just write <code class="language-plaintext highlighter-rouge">bind ctrl-right</code> or <code class="language-plaintext highlighter-rouge">bind alt-backspace</code>. This requires fish to understand what <code class="language-plaintext highlighter-rouge">\e\[1\;5C</code> <em>is</em> and to map it to an understanding of keys.</p>

<p>And this understanding of keys now goes deeper: Fish tries to get the terminal to encode keys better so that it can differentiate them better.</p>

<p>To explain, the usual protocol terminals use to send keys to applications have a lot of limitations: control+I (or control+shift+i) sends the exact same sequence as control+i, which sends the exact same sequence as the Tab key. A lot of keys cannot be disambiguated this way!</p>

<p>So fish now enables a variety of terminal features, including xterm’s “modifyOtherKey” and the kitty keyboard protocol<sup id="fnref:kkp"><a href="#fn:kkp" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>, that tell the terminal that fish understands when it sends better sequences. If this works, you can <code class="language-plaintext highlighter-rouge">bind ctrl-i</code>, <code class="language-plaintext highlighter-rouge">bind ctrl-I</code> and <code class="language-plaintext highlighter-rouge">bind tab</code> separately! If it doesn’t work, you can still use <code class="language-plaintext highlighter-rouge">bind ctrl-i</code>, but it will also be triggered when you press tab.</p>

<p>It does this automatically and without requiring configuration. We have tested a lot of terminals and found that almost all terminals we could get our hands on either understood these sequences and acted on them or harmlessly ignored them.</p>

<p>In some rare cases we encountered terminal bugs that we worked around by disabling these protocols. For instance we found issues in the integrated terminal in JetBrains IDEs or Wezterm<sup id="fnref:wezterm"><a href="#fn:wezterm" class="footnote" rel="footnote" role="doc-noteref">3</a></sup> and iTerm that we hope will be fixed soon. In other cases we have sent patches, for example we improved Zellij’s support for the kitty keyboard protocol.</p>

<p>If you <em>do</em> still see issues, like a mysterious “5u” or “=0” appearing in your commandline, you can disable these protocols for the time being with:</p>

<pre><code class="language-fish">set -Ua fish_features no-keyboard-protocols
</code></pre>

<p>Note that this is very likely a terminal bug, so it should be reported there.</p>

<p>The key notation is used by default, but we have added some exceptions so your existing bindings keep working. For example if a binding has a control character (like <code class="language-plaintext highlighter-rouge">\e</code>) inside, it will still be interpreted the old way. Our research tells us this should cover just about all bindings in the wild.</p>

<h3 id="commandline">Commandline</h3>

<p>Continuing on the theme of using terminal features if they are available, fish now also marks the prompt and command output with the OSC 133 sequences. That means it now better integrates with your terminal. In some cases terminals shipped “shell integration” scripts that wrote these in a hacky way, fish now just does it for them.</p>

<p>Similarly, fish now prints cursor change sequences for vi-mode in any terminal. Before, it would try to detect if the terminal was capable of it,
by sniffing for environment variables. Unfortunately, terminfo is in practice broken and useless, so this was necessary at the time.
But now these sequences are widespread enough that we can just use them and it won’t break terminals.</p>

<p>–</p>

<p>Fish now also handles commandlines that are longer than the screen correctly. Previously it would get confused and misrender them, now they scroll.</p>

<p>–</p>

<p>When you have a binding that makes a change with <code class="language-plaintext highlighter-rouge">commandline</code>, it now applies immediately. For instance if you do <code class="language-plaintext highlighter-rouge">commandline -i foo</code> that inserts “foo” into the commandline right away, where before it would add that change to the input queue. This makes it easier and in some ways <em>possible</em> to script your own bindings.</p>

<p>–</p>

<p>The ctrl-r history pager (which first shipped in fish 3.6.0) has a few neat improvements - you can now search for substrings with <code class="language-plaintext highlighter-rouge">*</code> glob syntax - <code class="language-plaintext highlighter-rouge">git*HEAD</code> will search for all history entries containing “git” and “HEAD” in that order.</p>

<p>It also only applies to the <em>current</em> command, so you can build bigger multiline scripts with it, instead of searching for the entire script.</p>

<p>–</p>

<p>The default theme had a slight adjustment: Instead of rendering commands as “blue”, it now leaves them in the terminal’s “normal” color.
For context, the default theme is supposed to be usable on as many systems as possible, which is why it restricts itself to the 16 color palette.
But making that readable on as many terminals as possible, no matter their palette, whether light or dark,
can be tricky. And we discovered that the default “blue” color on many terminals was hard to read on their default terminal background.
We think that’s a bit silly and the terminal’s palette should be improved, but we also need to support existing setups.
So we changed it, which also makes the default theme a bit less overloaded with color<sup id="fnref:salad"><a href="#fn:salad" class="footnote" rel="footnote" role="doc-noteref">4</a></sup>.</p>

<p>If you are already using the default theme, it will stay on the old version. To get the new colors, reload the theme via <code class="language-plaintext highlighter-rouge">fish_config</code>.</p>

<h3 id="abbreviations">Abbreviations</h3>

<p>Abbreviations had one big change: It is now possible to make an abbreviation only valid as an argument to certain commands.
For instance, you can use abbreviations with <code class="language-plaintext highlighter-rouge">git</code> instead of using git’s own aliases.</p>

<p>In the simple case this would just be <code class="language-plaintext highlighter-rouge">abbr --command git co checkout</code>, which will expand <code class="language-plaintext highlighter-rouge">co</code> to <code class="language-plaintext highlighter-rouge">checkout</code> when used with git,
but this will expand <em>any</em> <code class="language-plaintext highlighter-rouge">co</code> to checkout. You can add a function to parse git’s arguments in order to see if it’s a subcommand,
or you could see if it’s a commit-ish.</p>

<h3 id="self-installable-builds">Self-installable Builds</h3>

<p>There is also a new way to install fish: You can now build it as a “self-installable” binary.
That means you can compile a <code class="language-plaintext highlighter-rouge">fish</code> binary that includes all the functions, the man pages, the webconfig tool, embedded inside itself.
When you start it, it will ask to extract these to your home directory when they are missing or need to be updated.</p>

<p>You can use that to make statically-linked binaries that you can move around. So you can make a fish that works on, for example, any x86_64 linux.</p>

<p>One reason we hear for not using fish is that people ssh to servers where they won’t have it.
This change makes it easy to put it there, even if you don’t want to or can’t install a package. No more root permissions,
no fiddling with package sources. Just copy a file and run.</p>

<p>And creating a build like that is easy: <code class="language-plaintext highlighter-rouge">cargo build</code> will create it by default, so <code class="language-plaintext highlighter-rouge">cargo install</code> will install it.</p>

<p>We have also built these for x86_64 (aka “amd64”) and aarch64 (aka “arm64”) linux and uploaded them to <a href="https://github.com/fish-shell/fish-shell/releases/tag/4.0.0">the 4.0 github releases page</a><sup id="fnref:staticbuilds"><a href="#fn:staticbuilds" class="footnote" rel="footnote" role="doc-noteref">5</a></sup>.</p>

<h3 id="ignoring-commands-in-history">Ignoring Commands In History</h3>

<p>An older request was to make it possible to not add certain commands to history.</p>

<p>Other shells feature e.g. the “HISTIGNORE” variable that you can set to an expression for commands that should be ignored, like</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">HISTIGNORE</span><span class="o">=</span><span class="s2">"ls:[bf]g:exit:pwd:clear:mount:umount:[ </span><span class="se">\t</span><span class="s2">]*"</span>
</code></pre></div></div>

<p>Which is a bit un-fishy. So instead of introducing a special expression, we made it a function: <code class="language-plaintext highlighter-rouge">fish_should_add_to_history</code>. When you define this, you 
can choose to remove specific commands from your history. They will still stay as a single, temporary last entry, so you can always rerun the previous command,
but once you run something else they’re gone. This is like how fish handles commands prefixed with a space - and if you define your own <code class="language-plaintext highlighter-rouge">fish_should_add_to_history</code>
that also removes special handling for space-prefixed commands so you can decide to disable that feature.</p>

<h3 id="scripting-features">Scripting Features</h3>

<p>Fish’s scripting language also gained a bunch of new features. Most of these are a tad smaller, so let’s go through them:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">string match</code> now has a <code class="language-plaintext highlighter-rouge">--max-matches</code> option that can limit how many matches it reads until it considers its task successful. If you only want to know if <em>a match</em> is anywhere in a command’s output::
<code class="language-plaintext highlighter-rouge">foo | string match --max-matches=1 bar</code>
which can often quit much earlier.</li>
  <li><code class="language-plaintext highlighter-rouge">set</code> has a new <code class="language-plaintext highlighter-rouge">--no-event</code> option to suppress the variable change event, which is great if you want to change a variable in a handler for that variable.</li>
  <li><code class="language-plaintext highlighter-rouge">time</code> now starts measuring earlier, including any command substitutions.
Before, <code class="language-plaintext highlighter-rouge">time set foo (bar)</code> would only measure the time of <code class="language-plaintext highlighter-rouge">set foo ...</code>, now it will also measure the <code class="language-plaintext highlighter-rouge">bar</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">complete --erase</code> will now also stop fish from autoloading the completions again.
This is in line with <code class="language-plaintext highlighter-rouge">functions --erase</code>, and means you can now suppress completions for a command by putting <code class="language-plaintext highlighter-rouge">complete --erase thatcommand</code> in your config.fish</li>
</ul>

<p>Overall, we hope you’ll like this new release, which is a big step for fish’s future, but also a good one by itself.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:linecount">
      <p>This is discounting translations, since they easily baloon the line count (+420k, -373k) <a href="#fnref:linecount" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:kkp">
      <p>The “kitty keyboard protocol” was <em>invented</em> by kitty, but is also supported by a variety of other terminals, including ghostty or alacritty.
See <a href="https://sw.kovidgoyal.net/kitty/keyboard-protocol/">kitty’s documentation</a> for details on it. <a href="#fnref:kkp" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:wezterm">
      <p>Wezterm’s kitty keyboard protocol support is disabled by default, so we did not work around it. <a href="#fnref:wezterm" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:salad">
      <p>The term of art here is “angry fruit salad”. It’s easy to make a theme that overuses color, especially if you’re limited to the 16 color palette. <a href="#fnref:salad" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:staticbuilds">
      <p>Other systems are also possible, but we would like to focus on the big ones here because it is easy enough to make these yourself. <a href="#fnref:staticbuilds" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="release" /><summary type="html"><![CDATA[We’re proud to announce the release of fish 4.0.]]></summary></entry><entry><title type="html">Fish 4.0: The Fish Of Theseus</title><link href="https://fishshell.com/blog/rustport/" rel="alternate" type="text/html" title="Fish 4.0: The Fish Of Theseus" /><published>2024-12-28T00:00:00+01:00</published><updated>2024-12-28T00:00:00+01:00</updated><id>https://fishshell.com/blog/rustport</id><content type="html" xml:base="https://fishshell.com/blog/rustport/"><![CDATA[<p>About two years ago, our head maintainer @ridiculousfish opened what quickly became our most-read pull request:</p>

<ul>
  <li><a href="https://github.com/fish-shell/fish-shell/pull/9512">#9512 - Rewrite it in Rust</a></li>
</ul>

<p>Truth be told, we did not quite expect that to be as popular as it was.
It was written as a bit of an in-joke for the fish developers first, and not really as a press release to be shared far and wide.
We didn’t post it anywhere, but other people did, and we got a lot of reactions.</p>

<p>Observant readers will note that the PR was a proposal to rewrite the entirety of fish in Rust, from C++.</p>

<p>Fish is no stranger to language changes - it was ported from pure C to C++ earlier in its life,
but this was a much bigger project, porting to a much more different language that didn’t even exist when fish was started in 2007.</p>

<p>Now that we’ve released the beta of fish 4.0, containing 0% C++ and almost 100% pure Rust, let’s look back to see what we’ve learned, what went well, what could have gone better and what we can do now.</p>

<p>We’re writing this so others can learn from our experience, but it is <em>our</em> experience and not an exhaustive study.
We hope that you’ll be able to follow along even if you have never written any rust, but
experience with a roughly C++-shaped language should help.</p>

<h2 id="why-are-we-doing-this-again">Why are we doing this again?</h2>

<p>We’ve experienced some pain with C++. In short:</p>

<ul>
  <li>tools and compiler/platform differences</li>
  <li>ergonomics and (thread) safety</li>
  <li>community</li>
</ul>

<p>Frankly, the tooling around the language isn’t good, and we had to take on some additional pain in order to support our users.
We want to provide up-to-date fish packages for systems that aren’t up-to-date, like LTS Linux and older macOS.
But there is no ‘rustup’ for C++, no standard way to install recent C++ compilers on these operating systems.
This means adopting recent C++ standards would complicate the lives of packagers and would-be contributors<sup id="fnref:Contributions"><a href="#fn:Contributions" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>.
For example, we started using C++11 in 2016, and yet we still needed to upgrade the compilers on our build machines until 2020.</p>

<p>Fish also uses threads for its award-winning (<em>note to editor</em>: find an actual award) autosuggestions and syntax highlighting,
and one long-term project is to add concurrency to the language.</p>

<p>Here’s a dirty secret: while external commands run in parallel, fish’s execution of internal commands (builtins and functions) is currently serial and can’t be backgrounded. Lifting this limitation will enable features like asynchronous prompts or non-blocking completions, as well as performance gains.</p>

<p>POSIX shells use subshells to get around this, but subshells are a leaky abstraction that can bite you in the behind when you least expect it.
For instance, you can’t set variables from inside a pipe (except on some shells, but only in the last part of the pipe, maybe, if you have enabled the correct option).
We would like to avoid that, and so the heavy hand of forking off a process isn’t appealing.</p>

<p>We prototyped true multithreaded execution in C++, but it just didn’t work out. For example, it was too easy to accidentally share objects across threads, with only post-hoc tools like Thread Sanitizer to prevent it.</p>

<p>The ergonomics of C++ are also simply not good - header files are annoying, templates are complicated, you can easily cause a compile error that throws <em>pages</em> of overloads in the standard library at you. Many functions are unsafe to use. C++ string handling is very verbose with
easily confusable overloads of many methods, making it attractive to drop down to C-style char pointers, which are quite unsafe.</p>

<p>And the standard prioritizes performance over ergonomics. Consider for instance string_view, which provides a non-owning slice of a string. This is an extremely modern, well-liked feature that C++ programmers often claim is a great reason to switch to C++17. And it is extremely easy to run into use-after-free bugs with it, because the ergonomics weren’t a priority.</p>

<p>One good case study of the deficiencies of C++-in-practice is a C library: curses. This is a venerable library to access terminal features, and we use it to access the terminfo database, which describes differences in terminal features and behavior.</p>

<p>This not only caused us grief by being unsafe to use in weird ways - the “cur_term” pointer (or sometimes macro!) can be NULL, and it is dereferenced in surprising places, but also caused a surprisingly high number of issues when building from source. This was either because there are multiple implementations of it with differences as useless as “this function takes a char on system X but an int on system Y”, but also because users kept coming to us with new and exciting(ly terrible) ways to package and install it. The dependency system is the system package manager.</p>

<p>Finally, subjectively, C++ isn’t drawing in the crowds. We have never had a lot of C++ contributors. Over the 11 years fish used C++, only 17 people have at least 10 commits to the C++ code. We also don’t know a lot of people who would love to work on a C++ codebase in their free time.</p>

<p>Some parting thoughts we can give the C++ community: We would like to see improvements to ergonomics and safety of the language and the tools prioritized over performance, and we would like to see efforts to make C++ compilers easier to upgrade on real systems.</p>

<h2 id="why-rust">Why Rust?</h2>

<p>We need to get one thing out of the way: Rust is cool. It’s fun.</p>

<p>It’s tempting to try to sweep this under the rug because it feels gauche to say, but it’s actually important for a number of reasons.</p>

<p>For one, fish is a hobby project, and that means we want it to be fun for us. Nobody is being paid to work on fish, so we <em>need</em> it to be fun.
Being fun and interesting also attracts contributors.</p>

<p>Rust also has great tooling. The tools have really paid a lot of attention to use, and the compiler errors are terrific. Not even “compared to C++”, they just actually rule. And as we have tried to pay attention to our own error messages (fish has a bespoke error for if it thinks a file you told it to run has Windows line endings),
we like it.</p>

<p>And it is <em>easy</em> to get that tooling installed - <code class="language-plaintext highlighter-rouge">rustup</code> is magic, and allows people to get started quickly, with minimal fuss or root permissions.
When the answer to “how to upgrade C++ compiler” is “find a repository (with root permissions), compile it yourself, install some <em>other</em> repository or a docker image”,
it is amazing how the Rust answer can just be “use rustup”.</p>

<p>Rust has great ergonomics - the difference between C++’s pointers (which can always be NULL) and Rust’s Options are apparent very quickly even to those of us who had never used it before. We did have a backport of C++’s optional, and liked using it, but it was never as integrated as Rust’s Options were.</p>

<p>Having an explicit <code class="language-plaintext highlighter-rouge">use</code> system where you know exactly which function comes from which module is a great improvement over <code class="language-plaintext highlighter-rouge">#include</code>.</p>

<p>Rust makes it nice to add dependencies. We don’t want to go overboard with it, but we do want to change our history format from our homegrown “I can’t believe it’s not YAML” to something specified that other tools can actually read, and Rust makes it easy to add support for YAML/JSON/KDL.</p>

<p>But the killer feature of Rust, from fish-shell’s perspective, is Send and Sync, statically enforcing rules around threading. “Fearless concurrency” is too strong - you can still blow your leg off with fork or signal handlers - but Send and Sync will be the key to unlocking fully multithreaded execution, with confidence in its correctness.</p>

<p>We did not do a comprehensive survey of other languages. We were confident Rust was up to the task and either already knew it or wanted to learn it, so we picked it.</p>

<h2 id="platform-support">Platform Support</h2>

<p>A lot of hay has also been made online about Rust’s platform support (e.g. <a href="https://lwn.net/Articles/998115/">in the git project</a>). We don’t see a big problem here - all of our big platforms (macOS, Linux, the BSDs) are supported, as are Opensolaris/Illumos and Haiku. We have never heard of anyone trying to run fish on NonStop.</p>

<p>Architecture support is even less of a problem - going by <a href="https://popcon.debian.org/">Debian’s popcon</a>, 99.9995% (the actual result, not an exaggeration) of machines run an architecture that has Rust packages in Debian. Given that fish is <a href="https://qa.debian.org/popcon.php?package=fish">installed on 1.92% of Debian systems</a>, we would project two (2) or three (3) machines of the quarter million responses to have fish on an unsupported architecture <sup id="fnref:stats"><a href="#fn:stats" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>.</p>

<p>Unlike what some online have assumed, a native Windows port was not a reason for switching to Rust as it was never in the cards. Fish is, at heart, a UNIX shell that relies not only on UNIX APIs but also their semantics, and exposes them in the scripting language. What would <code class="language-plaintext highlighter-rouge">test -x</code> say on Windows, which has no executable bit? These are issues that <em>could</em> be solved with a lot of work, but we’re unix nerds making a unix shell, not one for Windows.</p>

<p>The one platform we care about a bit that it does not currently seem to have enough support for is Cygwin, which is sad, but we have to make a cut somewhere.</p>

<h2 id="the-story-of-the-port">The Story Of The Port</h2>

<p>We had decided we were gonna do a “Fish <a href="https://en.wikipedia.org/wiki/Ship_of_Theseus">Of Theseus</a>” port - we would move over, component by component, until no C++ was left.
And at every stage of that process, it would remain a working fish.</p>

<p>This was a necessity - if we didn’t, we would not have a working program for months, which is not only demoralizing but would also have precluded us from
using most of our test suite - which is end-to-end tests that run a script or fake a terminal interaction. We would also not have been able to do another C++ release,
putting some cool improvements into the hands of our users.</p>

<p>Had we chosen to disappear into a hole we might not have finished at all, and we would have to re-do a bunch of work once it became testable.
We also mostly kept the structure of the C++ code intact - if a function is in the “env” subsystem, it would stay there. Resisting the temptation to
clean up allowed us to compare the before and after to find places where we had mistranslated something.</p>

<p>So we used <a href="https://google.github.io/autocxx/">autocxx</a> to generate bindings between C++ and Rust code, allowing us to port one component at a time.</p>

<p>We started<sup id="fnref:technically"><a href="#fn:technically" class="footnote" rel="footnote" role="doc-noteref">3</a></sup> by porting the builtins. These are essentially little self-contained programs, with their own arguments, streams, exit code, etc.
That means it’s easy to port them separately from the rest of the shell once you have a way to call a Rust builtin from C++, which we had as part of the initial pull request.</p>

<p>Where they connected to the main shell, we used one of three approaches:</p>

<ol>
  <li>Add some FFI glue to the C++ to make it callable from Rust, port the caller and leave the callee for later</li>
  <li>Move the callee to Rust and, if necessary, make it callable from C++</li>
  <li>Write a Rust version of the callee and call it from the ported caller, but leave the C++ version around</li>
</ol>

<p>For instance, almost every builtin needs to parse its options. We have our own implementation of getopt, that we reimplemented in Rust in the initial PR,
but the C++ version stuck around until it had no more callers remaining. Otherwise we would have had to write a C++-to-Rust bridge and adjust the C++ callers to use it.</p>

<p>Or the <code class="language-plaintext highlighter-rouge">builtin</code> builtin (the builtin called <code class="language-plaintext highlighter-rouge">builtin</code>) needs access to the names of all builtins to print them for <code class="language-plaintext highlighter-rouge">builtin --get-names</code>. In that case we bridged some access to what amounts to a constant vector of strings in the C++, and eventually moved it over once the users were in Rust.</p>

<p>That’s how it went for a while, but we finally hit the more entangled systems, where porting larger chunks felt more productive,
since that reduced the amount of tricky FFI code to be written only to be thrown away. These were ported in solo efforts.
This includes the input/output “reader”, which is, unsurprisingly, one of fish’s biggest parts, ending up at about 13000 lines of Rust.</p>

<p>During the port, we hit a bunch of snags with (auto)cxx. Sometimes it would just not understand a particular C++ construct, and we spent a lot of time trying to figure out ways to please it. As an example, we introduced a struct on the C++ side that wrapped C++’s <code class="language-plaintext highlighter-rouge">vector</code>, because for some reason autocxx liked to complain about <code class="language-plaintext highlighter-rouge">vector&lt;wstring&gt;</code>. We had to fork it to add support for wstring/wchar, which is understandable because using wchar is a horrible decision - we only do it because it’s a historical mistake.</p>

<p>Similarly, we had to wrap some C++ variables in <code class="language-plaintext highlighter-rouge">unique_ptr</code> and similar to make the ownership rules understandable to (auto)cxx, or copy values that didn’t strictly need to be copied. This caused the performance during the port to go down quite a bit, but we regained all of it in most spots, and even beat the C++ version in some.</p>

<p>We also patched autocxx to remove the requirement to use <code class="language-plaintext highlighter-rouge">unsafe</code> to invoke any C++ API, because that would have obscured uses of <code class="language-plaintext highlighter-rouge">unsafe</code> that wouldn’t disappear just by porting the callee. We were building something temporary, so sometimes it is okay to do something a little underhanded.
If you used this for a permanent bridge between Rust and C++ in a few parts of your code, the <code class="language-plaintext highlighter-rouge">unsafe</code> markers might be useful, but in our case they were noise.</p>

<p>Because autocxx generated a lot of code, some tools also were less helpful than they’d usually be. rust-analyzer for instance was extremely slow.</p>

<p>So, even though our codebase was fairly amenable to being moved to Rust because we didn’t use exceptions or a lot of templates, autocxx isn’t the easiest to work with.
It is absolutely magical that it works at all, and it enabled us to do this port, but it has a hard task to perform and isn’t perfect at it.</p>

<h3 id="the-timeline">The Timeline</h3>

<ul>
  <li>
    <p>The initial PR was opened on 28th January 2023, merged on 19th February 2023</p>
  </li>
  <li>
    <p>fish 3.7.0, another release in the C++ branch to flush out some accumulated improvements, was released in January 2024</p>
  </li>
  <li>
    <p>The last C++ code was removed in January 2024 (and some additional test code was ported from C++ to C 12th of June 2024)</p>
  </li>
  <li>
    <p>The first beta was released 17th of December 2024</p>
  </li>
</ul>

<p>The initial PR had a timeline of “handwaving, half a year”. It was clear to all of us that it might very well be entirely off, and we’re not
disappointed that it was. Frankly, 14 months was still a pretty good pace, especially considering that we made a C++ release in-between, so it did not throw off our usual release cadence.</p>

<p>Most of the work was done by 7 people (going by those with at least 10 commits to “.rs” files), but we got a lot of help from interested community members.</p>

<p>The delay after that was down to a few reasons:</p>

<ol>
  <li>The “second 90%” - testing that everything worked. We flushed out a lot of bugs in this time, and if we made a release at that time it would have been a bad one.</li>
  <li>Having something to release that’s visible to users - there’s no point in making a release that does the same thing in new code, you need it to do different things.
So we held off until we had something.</li>
  <li>Simple availability - sometimes, some of us took time off.</li>
</ol>

<p>So if you are trying to draw any conclusions from this, consider the context: A group of people working on a thing in their free time,
diverting some effort to work on something else, <em>and</em> deciding that after the work is finished it actually isn’t.</p>

<h2 id="the-gripes">The Gripes</h2>

<p>It won’t surprise anyone who has spent any time on this world of ours that Rust is not, in fact, perfect. We have some gripes with it.</p>

<p>Chief among them is how Rust handles portability. While it offers many abstractions over systems, allowing you to target a variety of systems with the same code,
when it comes to <em>adapting</em> your code to systems at a lower-level, it’s all based on enumerating systems by hand, using checks like <code class="language-plaintext highlighter-rouge">#[cfg(any(target_os = "freebsd", target_os = "netbsd", target_os = "openbsd"))]</code>.</p>

<p>This is an imperfect solution, allowing you to miss systems and ignoring version differences entirely. From what we can tell, if FreeBSD 12 gains a function that we want to use, libc would add it, but calling it would then fail on FreeBSD 11 without a good way to check, at the moment.</p>

<p>But listing targets in our code is also fundamentally duplicating work that the libc crate (in our case) has already done. If you want to call libc::X, which is only defined on systems A, B and C, you need to put in that check for A, B and C yourself and if libc adds system D you need to add it as well. Instead of doing that, we are using our own <a href="https://github.com/mqudsi/rsconf">rsconf</a> crate to do compile-time feature detection in build.rs.</p>

<p>Most of this would be solved if Rust had some form of saying “compile this if that function exists” - <code class="language-plaintext highlighter-rouge">#[cfg(has_fn = "fstatat")]</code>. With that, the libc crate could do whatever checks it wants and fish would just follow what it did, and we could remove a lot of the use for rsconf. It would not really help support older distributions that lack some features, tho. That could be solved by something like the <a href="https://github.com/rust-lang/rfcs/pull/3036">min_target_API_version</a> cfg.</p>

<p>While we’re on portability, the tools also sometimes fail to consider other targets - clippy may warn about a conversion being useless when it isn’t on another system, it is often better to use <code class="language-plaintext highlighter-rouge">if cfg!(...)</code> instead of <code class="language-plaintext highlighter-rouge">#[cfg(...)]</code> because code behind the latter is eliminated very early, so it may be entirely wrong and only shows up when building on the affected system.</p>

<p>We’ve also had issues with localization - a lot of the usual Rust relies on format strings that are checked at compile-time, but unfortunately they aren’t translatable.
We ported printf from musl, which we required for our own <code class="language-plaintext highlighter-rouge">printf</code> builtin anyway, which allows us to reuse our preexisting format strings at runtime.</p>

<h3 id="the-mistakes">The Mistakes</h3>

<p>We’ve hit some false starts, dead ends and other kinds of mistakes. For instance we originally used a fancy macro to allow us to write our strings as <code class="language-plaintext highlighter-rouge">"foo"L</code>, but that did not end up carrying its weight and we removed it in favor of a regular <code class="language-plaintext highlighter-rouge">L!("foo")</code> macro call.</p>

<p>We were confused by a deprecation warning in the libc crate, which explains that “time_t” will be switched to 64-bit on musl in the future.
We initially tried to work around it, adding a lot of wrappers to try to stay agnostic on that size, but only later figured out that it does not affect us,
as we do not pass a time_t we get from one C library to another. (https://github.com/fish-shell/fish-shell/issues/10634)</p>

<p>Some bugs appeared because we missed subtleties of the original code.
Often this turned into a crash because we used asserts or assert’s modern cousin “.unwrap()”. This was often the easiest way to translate the C++,
and sometimes it simply turned out to be not accurate, and had to be replaced with different error handling.</p>

<p>But overall most of these were, once found, pretty shallow - “it panics here, why would it do that? oh, this can be an Err? Okay, what leads to that? Ah, okay, let’s handle that in this way”.</p>

<p>We’ve also caused some friction by turning on link-time-optimization combined with having release builds as the default in CMake (currently needed to run the full test suite),
which makes it easy to accidentally have very long build time.</p>

<h2 id="the-good">The Good</h2>

<p>A lot of the benefits of porting to Rust will appear over time, but some are already here.</p>

<p>Remember our issues with (n)curses? We will no longer have any, because we no longer use curses. Instead we switched to <a href="https://github.com/meh/rust-terminfo">a Rust crate</a> that gives us just what we need, which is access to terminfo and expanding its sequences. This removes some awkward global state, and means those building from source no longer need to ensure that curses is installed “correctly” on their system - cargo just downloads a crate and builds it.</p>

<p>We do still read terminfo, which means users need to install that, but that can be done at runtime, is preinstalled on all mainstream systems <em>and</em> if it can’t be found we just use an included copy of the xterm-256color definitions<sup id="fnref:terminfo"><a href="#fn:terminfo" class="footnote" rel="footnote" role="doc-noteref">4</a></sup>.</p>

<p>We have also managed to create “self-installable” fish packages that include all the functions, completions and other asset files in the fish binary to be written out at runtime.
That allowed us to create statically linked versions of fish (for linux this uses musl, because glibc has unavoidable crashes!), so for the first time we have <em>one file</em> you can download and run on <em>any linux</em> (the only requirement being that the architecture matches!).</p>

<p>This is a pretty big boon for people who want to use fish but sometimes ssh to servers, where they might not have root access to install a package. So they can just <code class="language-plaintext highlighter-rouge">scp</code> a single file and it’s available.</p>

<p>This might be possible with C23’s <code class="language-plaintext highlighter-rouge">#embed</code>, but Rust allowed us to do it now and, overall, pretty easily.</p>

<h2 id="the-sad">The Sad</h2>

<p>The one goal of the port we did not succeed in was removing CMake.</p>

<p>That’s because, while <code class="language-plaintext highlighter-rouge">cargo</code> is great at <em>building</em> things, it is very simplistic at <em>installing</em> them. Cargo wants everything in a few neat binaries,
and that isn’t our use case. Fish has about 1200 .fish scripts (961 completions, 217 associated functions), as well as about 130 pages of documentation (as html and man pages),
and the web-config tool and the man page generator (both written in python).</p>

<p>It also has a test suite that is light on unit tests but heavy on end-to-end script and interactive tests. The scripted tests run through our own littlecheck tool,
which runs a script and compares its output to embedded comments. The interactive tests are driven by pexpect, which fakes terminal interaction and checks that the right thing happens when you press buttons.</p>

<p>We kept cmake, in a simplified form, for these tasks, but let it hand over the responsibility of <em>building</em> to cargo.</p>

<p>It would be possible to switch all that to a simpler task runner like Just or even plain old makefiles, but since we already have this system we’re keeping it for now.
The upside is that the build process hasn’t really changed for packagers.</p>

<p>We’re also losing Cygwin as a supported platform for the time being, because there is no Rust target for Cygwin and so no way to build binaries targeting it.
We hope that this situation changes in future, but we had also hoped it would improve during the almost two years of the port.
For now, the only way to run fish on Windows is to use WSL.</p>

<h2 id="the-present--the-future">The Present &amp; The Future</h2>

<p>We’ve succeeded. This was a gigantic project and <em>we made it</em>. The sheer scale of this is perhaps best expressed in numbers:</p>

<ul>
  <li>1155 files changed, 110247 insertions(+), 88941 deletions(-) (excluding translations)</li>
  <li>2604 commits by over 200 authors</li>
  <li>498 issues</li>
  <li>Almost 2 years of work</li>
  <li>57K Lines of C++ to 75K Lines of Rust <sup id="fnref:formatting"><a href="#fn:formatting" class="footnote" rel="footnote" role="doc-noteref">5</a></sup> (plus 400 lines of C <sup id="fnref:ccode"><a href="#fn:ccode" class="footnote" rel="footnote" role="doc-noteref">6</a></sup>)</li>
  <li><a href="https://github.com/fish-shell/fish-shell/pull/10564">C++–</a></li>
</ul>

<p>The beta works very well. Performance is usually slightly better in terms of time taken, memory use has a slightly higher floor but a lower ceiling - it will use 8M instead of 7M at rest, but e.g. globbing a big directory won’t make it go up as much. These things can all be improved, of course, but for a first result it is encouraging.</p>

<p>Fish is still a bit of an odd duck…fish as a Rust program. It has some bits that smell like C spirit, directly using the C API and e.g. passing around file descriptors instead of File objects. It still uses UTF-32 strings - which is why we are using a fork of the pcre2 crate because we couldn’t convince the pcre2-crate maintainer to add UTF-32 support. We hope to find a nicer solution here, but it wasn’t necessary for the first release.</p>

<p>The port wasn’t without challenges, and it did not all go <em>entirely</em> as planned. But overall, it went pretty dang well. We’re now left with a codebase that we like a lot more, that has already gained some features that would have been much more annoying to add with C++,
with more on the way, and we did it while creating a separate 3.7 release that also included some cool stuff.</p>

<p>And we had fun doing it.</p>

<hr />

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:Contributions">
      <p>We rely on contributions from as diverse a set of people as we can for our completion scripts. We can only really get a completion script for a tool from
someone who knows that tool. And ideally, they would also test their script with the newest source from git - 
both to get more testing and to take advantage of new features we introduce.
So we want to make this as painless as possible. This is working rather well, overall - we have over 1000 completion scripts in our codebase. <a href="#fnref:Contributions" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:stats">
      <p>That is assuming that there isn’t a correlation between running fish and using an unusual processor architecture. Also this includes Hurd and kFreeBSD. <a href="#fnref:stats" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:technically">
      <p>Technically the first part of fish to be switched to rust is our <a href="https://github.com/ridiculousfish/widecharwidth">widecharwidth library</a>,
which already had a rust port that is used in Wezterm. <a href="#fnref:technically" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:terminfo">
      <p>We have discussed switching to not reading terminfo at all because in practice it is almost entirely useless. (we could write another 3000 words on the topic, but the short of it is that it is slow to update and integrate new features, often wrong, has no versioning mechanism and, most importantly, documents differences that barely exist anymore in the types of terminals that people actually use) <a href="#fnref:terminfo" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:formatting">
      <p>A lot of the increase in line count can be explained by rustfmt’s formatting, as it likes to spread code out over multiple lines, like:</p>
      <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">opts</span><span class="py">.show</span>
    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">opts</span><span class="py">.local</span>
        <span class="p">||</span> <span class="n">opts</span><span class="py">.function</span>
        <span class="p">||</span> <span class="n">opts</span><span class="py">.global</span>
        <span class="p">||</span> <span class="n">opts</span><span class="py">.erase</span>
        <span class="p">||</span> <span class="n">opts</span><span class="py">.list</span>
        <span class="p">||</span> <span class="n">opts</span><span class="py">.exportv</span>
        <span class="p">||</span> <span class="n">opts</span><span class="py">.universal</span><span class="p">)</span>
</code></pre></div>      </div>

      <p>which was one line in our C++ version.</p>

      <p>The rest is additional features.</p>

      <p>Also note that our Rust code is in some places a straight translation of the C++, and fully idiomatic Rust might be shorter. <a href="#fnref:formatting" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:ccode">
      <p>We use C in three places:</p>
      <ul>
        <li>To connect some functions or variables that aren’t (yet) in the libc crate</li>
        <li>To do compile-time feature detection</li>
        <li>In our fish_test_helper binary, which mocks some unix behaviors for tests
(things like “print blocked signals” or “acquire the terminal”)</li>
      </ul>
      <p><a href="#fnref:ccode" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="technical" /><summary type="html"><![CDATA[About two years ago, our head maintainer @ridiculousfish opened what quickly became our most-read pull request:]]></summary></entry><entry><title type="html">fish-shell 4.0b1, now in Rust</title><link href="https://fishshell.com/blog/fish-4b/" rel="alternate" type="text/html" title="fish-shell 4.0b1, now in Rust" /><published>2024-12-17T00:00:00+01:00</published><updated>2024-12-17T00:00:00+01:00</updated><id>https://fishshell.com/blog/fish-4b</id><content type="html" xml:base="https://fishshell.com/blog/fish-4b/"><![CDATA[<p>fish is a smart and user-friendly command line shell with clever features that just work, without needing an advanced degree in bash scriptology. Today we are announcing an open beta, inviting all users to try out the upcoming 4.0 release.</p>

<p>fish 4.0 is a big upgrade. It’s got lots of new features to make using the command line easier and more enjoyable, such as more natural key binding and expanded history search. And under the hood, we’ve rebuilt the foundation in Rust to embrace modern computing<sup id="fnref:modern-computing-advancements"><a href="#fn:modern-computing-advancements" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>.</p>

<p>🎶 The beta is open, the release notes are live, and we’re ready to party like it’s 1995! 💿</p>

<h3 id="try-the-fish-shell-40-beta-view-the-release-notes-here">Try the fish-shell 4.0 beta! View the <a href="https://fishshell.com/docs/4.0b1/relnotes.html">release notes here</a>.</h3>

<p>You can get the beta in the following ways:</p>
<ul>
  <li>Packages for macOS from the <a href="https://github.com/fish-shell/fish-shell/releases/tag/4.0b1">GitHub release page</a></li>
  <li>Using Homebrew on macOS: <code class="language-plaintext highlighter-rouge">brew install fish-shell/fish-beta-4/fish</code></li>
  <li>Using our PPA for Ubuntu: <code class="language-plaintext highlighter-rouge">sudo add-apt-repository ppa:fish-shell/beta-4; sudo apt install fish</code></li>
  <li>Using <a href="https://software.opensuse.org//download.html?project=shells%3Afish%3Abeta%3A4&amp;package=fish">prebuilt packages for other Linux distributions</a></li>
  <li>Using the portable binaries for Linux from the <a href="https://github.com/fish-shell/fish-shell/releases/tag/4.0b1">GitHub release page</a></li>
</ul>

<p>We are quite proud of this upcoming release. It represents a staggering amount of work and includes some really nice changes for users, as well as foundational improvements that will pay off in the future.</p>

<p>We consider this beta to be highly stable, and we use it as our primary shell. All existing fish scripts and commands are expected to keep working, with the exception of the items noted in the release notes<sup id="fnref:qmark-no-glob"><a href="#fn:qmark-no-glob" class="footnote" rel="footnote" role="doc-noteref">2</a></sup>. Whether you are an existing user, or curious to give fish a try, this is a great opportunity to contribute to fish-shell.</p>

<p>Command line users are endlessly inventive, so if you notice something that isn’t working as it should, that’s a problem and we’d like to hear about it! Please report any issues you encounter by filing a <a href="http://github.com/fish-shell/fish-shell/issues/">GitHub Issue</a>, or on our <a href="https://matrix.to/#/#fish-shell:matrix.org">Matrix channel</a>, which is also a great place to ask questions. Newbie questions welcome!</p>

<p>We will be publishing a follow-up post about the mechanics of the port from C++ to Rust: what went well, what could have gone better, and lessons learned.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:modern-computing-advancements">
      <p>Zip disks, Sound Blaster cards, etc. <a href="#fnref:modern-computing-advancements" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:qmark-no-glob">
      <p>In particular, the use of ? as a wildcard is now disabled by default through a feature flag. <a href="#fnref:qmark-no-glob" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>]]></content><author><name></name></author><category term="general" /><summary type="html"><![CDATA[fish is a smart and user-friendly command line shell with clever features that just work, without needing an advanced degree in bash scriptology. Today we are announcing an open beta, inviting all users to try out the upcoming 4.0 release.]]></summary></entry><entry><title type="html">Incomplete licensing information in previous fish releases</title><link href="https://fishshell.com/blog/licensing-error/" rel="alternate" type="text/html" title="Incomplete licensing information in previous fish releases" /><published>2024-01-13T00:00:00+01:00</published><updated>2024-01-13T00:00:00+01:00</updated><id>https://fishshell.com/blog/licensing-error</id><content type="html" xml:base="https://fishshell.com/blog/licensing-error/"><![CDATA[<p>During the work on fish 3.7.0, we discovered that the licensing
information in the documentation for some of the derived code contained in
fish had been removed during the work on fish 3.1.0, and that this was not
corrected until the release of fish 3.7.0. Although the source contained
the correct licensing information, this was not published as part of the
release’s documentation.</p>

<p>In particular, fish 3.1.0-3.6.4 contain:</p>
<ul>
  <li>Code derived from CMake under the BSD license</li>
  <li>Code derived from OpenBSD &amp; tmux under the OpenBSD license</li>
  <li>Code derived from glibc under the LGPL</li>
  <li>UTF-8 code by Alexey Vatchenko under the ISC license</li>
  <li>Code from NetBSD under the NetBSD license</li>
  <li>Code from AngularJS/Google under the MIT license</li>
</ul>

<p>While these are noted in the source code, the user-visible documentation
does not contain an appropriate acknowledgement.</p>

<p>We regret the error. It was discovered during a routine audit of the code
and documentation for fish, which will occur during the release cycle on
an ongoing basis.</p>]]></content><author><name></name></author><category term="general" /><summary type="html"><![CDATA[During the work on fish 3.7.0, we discovered that the licensing information in the documentation for some of the derived code contained in fish had been removed during the work on fish 3.1.0, and that this was not corrected until the release of fish 3.7.0. Although the source contained the correct licensing information, this was not published as part of the release’s documentation.]]></summary></entry><entry><title type="html">fish shell 3.7.0 released</title><link href="https://fishshell.com/blog/release-3-7-0/" rel="alternate" type="text/html" title="fish shell 3.7.0 released" /><published>2024-01-03T00:00:00+01:00</published><updated>2024-01-03T00:00:00+01:00</updated><id>https://fishshell.com/blog/release-3-7-0</id><content type="html" xml:base="https://fishshell.com/blog/release-3-7-0/"><![CDATA[<p>fish shell 3.7.0 has been released. For the full list of changes, see <a href="https://fishshell.com/docs/3.7/relnotes.html">the release notes</a>.</p>]]></content><author><name></name></author><category term="release" /><summary type="html"><![CDATA[fish shell 3.7.0 has been released. For the full list of changes, see the release notes.]]></summary></entry><entry><title type="html">What’s happening with fish releases?</title><link href="https://fishshell.com/blog/release-updates/" rel="alternate" type="text/html" title="What’s happening with fish releases?" /><published>2023-05-27T00:00:00+02:00</published><updated>2023-05-27T00:00:00+02:00</updated><id>https://fishshell.com/blog/release-updates</id><content type="html" xml:base="https://fishshell.com/blog/release-updates/"><![CDATA[<p>Here is a quick update on fish development and the plans for a new release.</p>

<p>Earlier this year, the fish committers agreed to undertake a significant rework
of the fish source code. In particular, efforts are underway to change the C++
core of fish to Rust. There are several reasons for this rewrite, including that
it enables development of a concurrent execution mode to allow background
execution of fish functions and related benefits. There’s an <a href="https://github.com/fish-shell/fish-shell/pull/9512">extended
discussion on GitHub</a>, if
you’re interested.</p>

<p>However, this is a process that is likely to take six months or more. In that
time the source tree will probably not be suitable for general release. The
performance of the partially-rewritten program is worse and building it is more
complicated. <a href="https://github.com/fish-shell/fish-shell/wiki/Development-builds">Development
builds</a> are
currently not being generated because they’re frankly more trouble than they’re
worth.</p>

<p>The process is going reasonably well, with about 20% of the C++ code
removed in the last few months (as I measure it anyway). However, my
estimate is that it will not be ready for beta testing until late 2023
at the earliest.</p>

<p>There’s a <a href="https://github.com/fish-shell/fish-shell/issues?q=milestone%3A%22fish+3.6.2%22">handful of fixes for fish
3.6.1</a> that I think are worth rolling
up and <a href="https://github.com/fish-shell/fish-shell/discussions/9684">making a 3.6.2
release</a> for, though I don’t have a specific
timeline for doing so.</p>

<p>Hope that helps keep you informed!</p>

<p>David Adam &lt;<a href="https://github.com/zanchey">zanchey@</a>&gt;<br />
fish committer</p>]]></content><author><name></name></author><category term="general" /><summary type="html"><![CDATA[Here is a quick update on fish development and the plans for a new release.]]></summary></entry><entry><title type="html">fish shell 3.6.0 released</title><link href="https://fishshell.com/blog/release-3-6-0/" rel="alternate" type="text/html" title="fish shell 3.6.0 released" /><published>2023-01-07T00:00:00+01:00</published><updated>2023-01-07T00:00:00+01:00</updated><id>https://fishshell.com/blog/release-3-6-0</id><content type="html" xml:base="https://fishshell.com/blog/release-3-6-0/"><![CDATA[<p>fish shell 3.6.0 has been released. Major new features include Control-R support for history search, and more powerful and customizable abbreviations. For the full list of changes, see <a href="https://fishshell.com/docs/3.6/relnotes.html">the release notes</a>.</p>

<p>A big thank you to all contributors who helped make this release great!</p>]]></content><author><name></name></author><category term="release" /><summary type="html"><![CDATA[fish shell 3.6.0 has been released. Major new features include Control-R support for history search, and more powerful and customizable abbreviations. For the full list of changes, see the release notes.]]></summary></entry><entry><title type="html">fish shell 3.4.1 released</title><link href="https://fishshell.com/blog/release-3-4-1/" rel="alternate" type="text/html" title="fish shell 3.4.1 released" /><published>2022-03-25T00:00:00+01:00</published><updated>2022-03-25T00:00:00+01:00</updated><id>https://fishshell.com/blog/release-3-4-1</id><content type="html" xml:base="https://fishshell.com/blog/release-3-4-1/"><![CDATA[<p>fish shell 3.4.1 has been released, fixing some regressions identified in 3.4.0. For the full list of changes, see <a href="https://fishshell.com/docs/3.4/relnotes.html">the release notes</a>.</p>]]></content><author><name></name></author><category term="release" /><summary type="html"><![CDATA[fish shell 3.4.1 has been released, fixing some regressions identified in 3.4.0. For the full list of changes, see the release notes.]]></summary></entry><entry><title type="html">fish shell 3.4.0 released</title><link href="https://fishshell.com/blog/release-3-4-0/" rel="alternate" type="text/html" title="fish shell 3.4.0 released" /><published>2022-03-12T00:00:00+01:00</published><updated>2022-03-12T00:00:00+01:00</updated><id>https://fishshell.com/blog/release-3-4-0</id><content type="html" xml:base="https://fishshell.com/blog/release-3-4-0/"><![CDATA[<p>fish shell 3.4.0 has been released. This release includes support for <code class="language-plaintext highlighter-rouge">$(cmd)</code> command substitutions, a terminal interface to change themes, faster globbing, the ability to disable autosuggestions, and more. For the full list of changes, see <a href="https://fishshell.com/docs/3.4/relnotes.html">the release notes</a>.</p>

<p>A big thank you to all contributors who helped make this release great!</p>]]></content><author><name></name></author><category term="release" /><summary type="html"><![CDATA[fish shell 3.4.0 has been released. This release includes support for $(cmd) command substitutions, a terminal interface to change themes, faster globbing, the ability to disable autosuggestions, and more. For the full list of changes, see the release notes.]]></summary></entry><entry><title type="html">fish shell 3.3 released</title><link href="https://fishshell.com/blog/release-3-3/" rel="alternate" type="text/html" title="fish shell 3.3 released" /><published>2021-06-29T00:00:00+02:00</published><updated>2021-06-29T00:00:00+02:00</updated><id>https://fishshell.com/blog/release-3-3</id><content type="html" xml:base="https://fishshell.com/blog/release-3-3/"><![CDATA[<p>fish shell 3.3 has been released with many improvements. For the full list of changes, see <a href="https://fishshell.com/docs/3.3/relnotes.html">the release notes</a>.</p>

<p>A big thank you to all contributors who helped make this release great!</p>]]></content><author><name></name></author><category term="release" /><summary type="html"><![CDATA[fish shell 3.3 has been released with many improvements. For the full list of changes, see the release notes.]]></summary></entry></feed>