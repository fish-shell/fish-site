---
layout: post
title: "fish-shell 4.0b and the Rust port"
date: 2024-11-09
categories: general
---

fish is a smart and user-friendly command line shell (like bash or zsh) with clever features that work out of the box, with nothing new to learn or configure.

fish-shell is approaching its 4.0 milestone, the first release since porting from C++ to Rust. Today we are announcing an open beta, inviting all users to try out the upcoming 4.0 release.

### **Try the fish-shell 4.0 beta at [fishshell.com](https://fishshell.com)**. View the [release notes here](https://fishshell.com/docs/current/relnotes.html).

If you are an existing fish user, or are curious to give it a try, this is a great opportunity to improve your command line experience while contributing to fish. Please report any issues you encounter by filing a [GitHub Issue](http://github.com/fish-shell/fish-shell/issues), or on our [Matrix channel](https://matrix.to/#/#fish-shell:matrix.org), which is also a great place to ask questions. Newbie questions welcome!

The remainder of this post will discuss the mechanics of the port.

### By the numbers

The port was proposed in February 2023. January 2024 marked the elimination of C++ from the fish-shell codebase; this was then followed by a period of testing, fixes, and preparation for the release.

Prior to the port, fish-shell had over 47k lines of code in C++ source files, and nearly 8k lines in C++ header files. Today, fish has over 75k lines of Rust. This increase is explained by Rust's explicit `use` constructs compared to C++'s umbrella headers, `rustfmt` vs `clang-format` differences, the need to re-implement `printf`, and some additional features added in the interim.

### Why port

fish-shell was originally written in C, in 2005. It was ported to C++ in 2011, for improved memory management, and C++ served fish-shell well for a decade.

But eventually, problems arose. Modern C++ is challenging to learn and makes it difficult to attract new developers. fish-shell maintains compatibility with older operating systems, limiting us to C++11 with no clear upgrade path. Lastly, fish-shell has a long-term goal of enabling fully multithreaded execution, and prototypes of this in C++ proved unpromising. For example, it was too easy to accidentally share objects across threads, with only post-hoc tools like Thread Sanitizer to prevent it.

So we decided to port to a new language.

### How to port

A key requirement was that the port would be _incremental_: not a "big bang" rewrite, but instead one module or even function at a time, with a usable shell and all tests passing at each commit. This required strong language interoperability (i.e. an FFI), as both C++ and the target language would coexist for a period.

We maintained the existing style in the ported code. This resulted in code that was not exactly idiomatic, but was easier to compare and review. For example, ported code used for loops instead of iterator chains. After we had confidence in the correctness of the ported code, we refactored it to a more idiomatic style.

### Why Rust

Rust was chosen because of a combination of an active and energetic community, the right architecture to support the port, and its concurrency guarantees.

Community is most important. Open-source projects live and die based on the community, on people volunteering their time. Rust has cultivated an active, enthusiastic community, with a systems programming bent. This community offers fish-shell a strong network of potential contributors.

Rust's underlying semantics are also similar to C++, which allowed for a straightforward, incremental port. We used (forked) versions of [CXX](https://cxx.rs) and [autocxx](https://google.github.io/autocxx/) to allow C++ and Rust to interoperate. Had we chosen a language with (say) green threads or garbage collection, it would have complicated the FFI, and likely forced a redesign of fish's signal handling and async-signal-safe code.

But the killer feature of Rust, from fish-shell's perspective, is Send and Sync, statically enforcing rules around threading. "Fearless concurrency" is too strong - you can still blow your leg off with fork or signal handlers - but Send and Sync will be the key to unlocking fully multithreaded execution, with confidence in its correctness.

### The port

The port went more or less according to plan. Some new contributors pitched in, as we hoped - thank you to [Xiretza](https://github.com/Xiretza) and [henrikhorluck](https://github.com/henrikhorluck).

Some parts of fish proved too entangled to port separately, resulting in some large PRs. And some bugs were introduced, and then later discovered and fixed. But overall the plan was highly successful: fish is now in Rust!

### Hurdles

Rust is powerful and widely appreciated, but we discovered areas of immaturity or missing features:

- Configuration-time checks. For example, `cur_term` is a _symbol_ on some Linux distributions but a C _macro_ on others, making it difficult to consistently access in Rust. We wrote [our own crate](https://github.com/mqudsi/rsconf) to support configuration-time checks.

- Universal macOS binaries, a surprise given Rust's reputation for cross-compilation. We implemented this manually with a shell script.

- Runtime format strings, which are needed for localization. We used gettext and (our own) printf instead of using `format!`.

- libc macros: `_PATH_BSHELL`, `MNT_LOCAL`, `MB_CUR_MAX`, etc. We exposed these via a C file, which (sadly) requires a C compiler.

- We [implemented printf](https://crates.io/crates/fish-printf), as the existing 'printf' crates in crates.io were not standards-conforming and/or required nightly Rust.

- Auxiliary tasks such as building Sphinx documentation, installer packages, running tests not written in Rust, etc. Cargo is focused exclusively on Rust so we needed another tool to drive these tasks, and we kept CMake.

The big surprise from the port was retaining CMake for these auxiliary tasks. fish can be built and run via cargo alone, but CMake still drives the rest. We have a newfound respect for CMake, which has solved many of the problems we encountered, even as we transition off of it.

# Conclusion

The Rust port was successful. fish-shell is battle-tested, and yet has proven adaptable and able to evolve. fish is the best it has ever been, and there is so much more on the horizon.

Rust is NOT a feature of fish, but a foundation that enables new features, by making it easier for new contributors to join, and through Rust’s language capabilities.

If you are a fish user, Rust developer, or both, then this is a special time to get involved in fish. With the new Rust foundation, it’s easier than ever to contribute, and we are a laid-back, positive community. Contributions are welcome. Come join us!
